"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIndex = useIndex;

var _index = _interopRequireDefault(require("instantsearch.js/cjs/widgets/index/index"));

var _react = require("react");

var _useIndexContext = require("../lib/useIndexContext");

var _useInstantSearchServerContext = require("../lib/useInstantSearchServerContext");

var _useInstantSearchSSRContext = require("../lib/useInstantSearchSSRContext");

var _useForceUpdate = require("./useForceUpdate");

var _useIsomorphicLayoutEffect = require("./useIsomorphicLayoutEffect");

var _useStableValue = require("./useStableValue");

function useIndex(props) {
  var serverContext = (0, _useInstantSearchServerContext.useInstantSearchServerContext)();
  var ssrContext = (0, _useInstantSearchSSRContext.useInstantSearchSSRContext)();
  var parentIndex = (0, _useIndexContext.useIndexContext)();
  var stableProps = (0, _useStableValue.useStableValue)(props); // On SSR rendering, we add the Index early in a memo to render the initial
  // results in the render pass. Since the Index is added already, we need to
  // skip the usual browser effect that adds the widget when client-side
  // rendering. We still need to run the effect lifecycle on all the other renders.
  // This ref lets us keep track whether the initial effect to add the Index
  // should be skipped.

  var shouldAddIndexRef = (0, _react.useRef)(true);
  var indexWidget = (0, _react.useMemo)(function () {
    var instance = (0, _index.default)(stableProps); // On the server, we directly add the Index in the memo scope to retrieve
    // its child widgets' search parameters in the render pass.
    // On SSR, we also add the Index here to synchronize the search state associated
    // to the widgets.
    // In these environments, we flag that we've added the widgets early to skip
    // the initial browser effect that would otherwise add the Index a second time.

    if (serverContext || ssrContext !== null && ssrContext !== void 0 && ssrContext.initialResults) {
      parentIndex.addWidgets([instance]);
      shouldAddIndexRef.current = false;
    }

    return instance;
  }, [parentIndex, serverContext, ssrContext === null || ssrContext === void 0 ? void 0 : ssrContext.initialResults, stableProps]);
  var helper = indexWidget.getHelper();
  var forceUpdate = (0, _useForceUpdate.useForceUpdate)();
  (0, _react.useEffect)(function () {
    forceUpdate();
  }, [helper, forceUpdate]);
  (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(function () {
    if (shouldAddIndexRef.current) {
      parentIndex.addWidgets([indexWidget]);
    }

    return function () {
      parentIndex.removeWidgets([indexWidget]);
      shouldAddIndexRef.current = true;
    };
  }, [parentIndex, indexWidget]);
  return indexWidget;
}